---
title: "HTML comme fondation"
date: "2022-12-22T16:53:57"
modified: "2022-12-22T16:54:59"
permalink: "html-comme-fondation/index.html"
excerpt: "<p>Traduction de <a href="https://www.htmhell.dev/adventcalendar/2022/17/">ma contribution au calendrier de l’avent de HTMHell</a>&nbsp;! <a href="https://www.ffoodd.fr/html-comme-fondation/" aria-hidden="true">Lire la suite de «&nbsp;HTML comme fondation&nbsp;» <span class="meta-nav">&rarr;</span></a></p>
"
format: "standard"
---
<p><strong>Note</strong> : cet article est la traduction de <a href="https://www.htmhell.dev/adventcalendar/2022/17/">ma contribution au calendrier de l’avent de HTMHell, <cite lang="en">Modern HTML as a foundation for progressive enhancement</cite></a>&nbsp;!</p>
<p>Vous êtes peut-être familier avec le concept d’amélioration progressive. En résumé, c’est une méthode permettant de s’assurer que l’utilisateur dispose d’<strong>une version viable</strong> de votre page quelque soit son contexte — connexion limitée, navigateur désuet, etc. — mais aussi de rendre ladite page plus <strong>résiliente</strong> (par exemple aux erreurs JavaScript).</p>
<p>L’amélioration progressive débute par la base :</p>
<ol>
<li>le <strong>contenu</strong>,</li>
<li>balisé avec <strong>HTML</strong>,</li>
<li>stylé avec <strong>CSS</strong>,</li>
<li>enrichi avec <strong>JavaScript</strong>,</li>
<li>et amélioré pour l’accessibilité avec <strong>ARIA</strong> (en cas de besoin uniquement).</li>
</ol>
<p>Chacune de ces étapes devrait fonctionner telle quelle et améliorer les étapes précédentes sans les abîmer. En d’autres termes, il vous faut rédiger votre HTML indépendamment du CSS ou du JavaScript que vous y appliquerez ensuite.</p>
<p>Cela étant dit, il paraît évident que mieux vous connaissez chaque étape de la liste, plus votre page devrait être robuste. <strong>JavaScript est omniprésent</strong> donc je présume que vous en êtes familier. <strong>ARIA devient de plus en plus visible</strong> depuis quelques années, donc on peut supposer que même sans connaître ARIA vous utilisez une bibliothèque ou un outil s’en occupant très bien. <strong>CSS s’améliore constamment</strong> et j’imagine que votre veille vous permet de découvrir des nouveautés quotidiennement ou presque…</p>
<p>Mais quid de HTML ? Fait-il partie de votre <strong>veille technique</strong> ? Voyez-vous fréquemment passer des nouveautés HTML dans vos flux d’information ? Pas très souvent, je présume.</p>
<p>Mais voilà. HTML est un standard vivant donc les spécifications changent, les navigateurs améliorent leurs supports en permanence — avec <a href="https://wpt.fyi/interop-2022">Interop 2022</a> par exemple — donc il y a des nouveautés, côté spécifications ou côté navigateurs ; et certains d’entre eux sont destinés à devenir des versions natives de composants JavaScript basés sur un amas de <code>div</code> depuis des lustres.</p>
<p>Et si nous pouvions améliorer la couche HTML pour ce genre de composants, rendant le balisage plus résilient au passage ?</p>
<p><strong>Avertissement</strong> : il faut voir HTML comme <strong>une fondation, en aucun cas un remplacement</strong> de votre composant JavaScript existant. Si votre composant requière ARIA, ne tentez pas de l’implémenter sans. Autrement dit, tentez systématiquement de fournir la meilleure expérience utilisateur possible et ne vous préoccupez pas trop de l’expérience développeur. Vous pourriez être intéressé par <a href="https://adrianroselli.com/2022/10/under-engineered-patterns-for-a11ytoconf.html#References">la série d’articles sur les composants sous-conçus d’Adrian Roselli</a>.</p>
<p>Allons faire une ballade !</p>
<h2><code>details</code> et <code>summary</code> comme base pour le motif de conception <i>disclosure</i></h2>
<p>Remémorez-vous ces boutons « Voir plus » qui font apparaître des contenus supplémentaires quand vous les activez. Rendre ce genre de composant accessible nécessite généralement que vous implémentiez le motif de conception ARIA <i>disclosure</i>, basé sur un bouton et l’attribut <code>aria-expanded</code> pour communiquer l’état.</p>
<p><code>&lt;details&gt;</code> et <code>summary&gt;</code> sont les candidats parfaits pour ça. Comme leur nom l’indique, ce motif de balisage va afficher un résumé (<i>summary</i>) et masquer les détails associés, mais les rendre disponibles lors de l’activation du résumé. <a href="https://thepaciellogroup.github.io/AT-browser-tests/test-files/details-summary.html">L’implémentation par les navigateurs</a> et <a href="https://caniuse.com/details">le support</a> sont excellents.</p>
<p>Ça semble plutôt sympa, non ? Alors pourquoi s’embarrasser avec le motif de conception <i>disclosure</i> et ne pas préférer utiliser <code>&lt;details&gt;</code> et <code>&lt;summary&gt;</code> systématiquement ? Pour faire simple, les interactions ne sont pas exactement celles attendues par vos utilisateurs, et le support par les navigateurs et technologies d’assistance n’est pas encore idéal — <a href="https://www.scottohara.me/blog/2022/09/12/details-summary.html">comme l’a démontré Scott O&rsquo;Hara</a>.</p>
<p>Mais alors… peut-on l’utiliser comme la fondation de notre motif de conception ARIA <i>disclosure</i> ? <a href="https://codepen.io/ffoodd/pen/XWYmmGj">Découvrons ça (sur CodePen)</a>&nbsp;!</p>
<p>Rien de magique ici : pour améliorer et harmoniser le support des technologies d’assistance, on transforme le motif HTML en <i>disclosure</i> en ajoutant à l’élément <code>&lt;summary&gt;</code> le rôle <code>button</code> et l’attribut <code>aria-expanded</code> pour expliciter l’état, et en s’assurant que le contenu masqué l’est pour tout le monde avec l’attribut <code>hidden</code>. L’attribut <code>open</code> sur l’élément <code>&lt;details&gt;</code> se charge de tout ça nativement, mais <a href="https://www.scottohara.me/blog/2022/09/12/details-summary.html#impact-of-removing-the-default-disclosure-triangle">on ne peut pas se reposer dessus dès qu’on personnalise le marqueur triangle par défaut</a> (ce qu’on fera à n’en pas douter) : on doit implémenter le motif de conception <i>disclosure</i> complet pour éviter des restitutions incohérentes entre navigateurs et technologies d’assistance.</p>
<p>De plus, saviez-vous que les navigateurs basés sur Chromium permettent de trouver le contenu masqué par <code>&lt;details&gt;</code> lors d’une recherche sur la page ? C’est une fonctionnalité qui va être standardisée en HTML avec <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/hidden#the_hidden_until_found_state">la valeur <code>until-found</code> pour l’attribut <code>hidden</code></a> mais ça n’est pas censé être le cas des contenus masqués par le motif de conception <i>disclosure</i>.</p>
<p>Comme vous l’avez peut-être compris, utiliser <code>&lt;details&gt;</code> et <code>&lt;summary&gt;</code> enrichis avec le motif de conception ARIA <i>disclosure</i> ne fera aucune différence pour la plupart des utilisateurs… mais si d’aventure votre JS ou votre CSS ne fonctionne pas, votre balisage sémantique prendra le relai et restera interactif — avec toutes ses limitations actuelles dans les technologies d’assistance.</p>
<p>Faites d’ailleurs attention en utilisant ces éléments comme fondation : ils ne sont pas le bon choix <a href="https://daverupert.com/2019/12/why-details-is-not-an-accordion/">pour des accordéons</a>, <a href="https://melsumner.github.io/details-as-a-menu">un menu déroulant</a>, <a href="https://cloudfour.com/thinks/a-details-element-as-a-burger-menu-is-not-accessible/">un menu « burger »</a>, <a href="https://adrianroselli.com/2019/04/details-summary-are-not-insert-control-here.html">un groupe d’onglets ou une fenêtre modale</a>… Restez sémantiques !</p>
<p>Et si je vous disais qu’il y a d’autres éléments HTML améliorables progressivement de la sorte ? On jette un œil ?</p>
<h2><code>output</code> comme une <i>live region</i></h2>
<p>Avez-vous déjà eu besoin d’alimenter une <i>live region</i> pour communiquer des changements aux utilisateurs de lecteurs d’écran — parfois <a href="https://www.ffoodd.fr/cache-cache-css/">masquée visuellement en CSS</a> ? C’est assez fréquent de nos jours, et vous retrouverez une gestion des <i>live regions</i> dans la plupart des <i>frameworks</i> : <a>Angular a un <code>LiveAnnouncer</code> dans son <abbr title="Component Dev Kit">CDK</abbr> Accessibilité</a>, et <a href="https://make.wordpress.org/accessibility/handbook/markup/wp-a11y-speak/">WordPress a un script interne <code>wp.a11y.speak()</code></a>… <a href="https://developer.mozilla.org/fr/docs/Web/Accessibility/ARIA/ARIA_Live_Regions">Les <i>live regions</i> ARIA s’appuient sur trois rôles spécifiques : <code>status</code>, <code>log</code> et <code>alert</code></a>, chacune ayant un comportement légèrement différent.</p>
<p>Mais saviez-vous qu’un élément HTML est une <i>live region</i> native, avec un rôle implicite <code>status</code> ? <a href="https://developer.mozilla.org/fr/docs/Web/HTML/Element/output">Je vous présente <code>&lt;output&gt;</code></a> ! <a href="https://thepaciellogroup.github.io/AT-browser-tests/test-files/output.html">L’implémentation par les navigateurs est complète</a> et <a href="https://caniuse.com/mdn-html_elements_output">le support est excellent</a>. Cependant certains couples de navigateurs et technologies d’assistance précis sont défectueux, comme <a href="https://www.scottohara.me/blog/2019/07/10/the-output-element.html">Scott O&rsquo;Hara (à nouveau) l’a démontré</a>.</p>
<p><a href="https://codepen.io/ffoodd/pen/rNvqGBB">Rendons <code>&lt;output&gt;</code> encore plus robuste en le transformant en <i>live region</i> ARIA (sur CodePen)</a>&nbsp;!</p>
<p>Vous vous en souvenez peut-être, expliciter les rôles des éléments HTML était nécessaire il y a quelques années — pour les <i>landmarks</i>, principalement — afin d’améliorer le support des navigateurs et technologies d’assistance. C’est d’ailleurs toujours une pratique encouragée par <a href="https://www.numerique.gouv.fr/publications/rgaa-accessibilite/methode-rgaa/criteres/#crit-12-6">le critère 12.6 du RGAA</a>. Nous nous sommes habitués à écrire <code>&lt;main role=&quot;main&quot;&gt;</code>, <code>&lt;header role=&quot;banner&quot;&gt;</code>, etc.</p>
<p>Un autre point positif avec <code>&lt;output role=&quot;status&quot;&gt;</code> est que ça vous permet de styler vos <i>live regions</i> en sélectionnant l’élément <code>output</code> : spécificité moins élevée, et la possibilité d’appliquer des styles de base renforcés — avec <i>CSS containment</i>, par exemple ?</p>
<h3>Une <i>live region</i> particulière : le toast !</h3>
<p>Il existe aussi un cas d’usage pour une <i>live region</i> affichée visuellement. Je n’irais pas très loin sur le sujet, car il a déjà été traité dans un grand nombre d’articles de grande qualité :</p>
<ul>
<li><a href="https://www.scottohara.me/blog/2019/07/10/the-output-element.html">Scott O&rsquo;Hara l’a mentionné dans <cite lang="en">The Output Element</cite></a>,</li>
<li>une précision technique après <a href="https://www.scottohara.me/blog/2019/07/08/a-toast-to-a11y-toasts.html"><cite lang="en">A toast to an accessible toast…</cite> abordant les considérations d’expérience utilisateur</a>,</li>
<li>mais aussi <a href="https://adrianroselli.com/2020/01/defining-toast-messages.html">Adrian Roselli avec <cite lang="en">Defining toast message</cite></a>.</li>
</ul>
<p><strong>Attention</strong> : si votre toast ou votre <i>live region</i> contient des éléments interactifs, vous devriez probablement utiliser un rôle <code>dialog</code> ou <code>alertdialog</code> au lieu d’un élément <code>&lt;output&gt;</code>. Cela dit… il y a peut-être un élément HTML plus indiqué pour ça !</p>
<h2>Une boîte de <code>dialog</code></h2>
<p>Je ne vais pas creuser beaucoup <a href="https://developer.mozilla.org/fr/docs/Web/HTML/Element/dialog">l’élément <code>&lt;dialog&gt;</code></a>, mais explorons tout de même ce qu’il fait nativement comparé au <a href="https://www.w3.org/WAI/ARIA/apg/patterns/dialogmodal/">modèle de conception ARIA dialog</a> :</p>
<ul>
<li>il a un rôle <code>dialog</code> implicite,</li>
<li>si on l’ouvre avec la méthode <code>showModal()</code> :
<ul>
<li>il a une propriété <code>aria-modal=&quot;true&quot;</code> implicite,</li>
<li>il peut être fermé avec la touche <kbd>Échap</kbd>,</li>
</ul>
</li>
<li>il piège le focus en son sein — mais permet d’atteindre la fenêtre du navigateur, c’est toujours discuté…</li>
<li>il restaure le focus à l’élément qui a déclenché l’ouverture, lors de sa fermeture,</li>
<li>il rend le reste du document <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/inert"><code>inert</code></a> automatiquement.</li>
</ul>
<p>Mais il y a plus ! Voyez plutôt :</p>
<ul>
<li><a href="https://developer.mozilla.org/fr/docs/Web/CSS/::backdrop">Le pseudo-élément <code>::backdrop</code></a> permet de styler l’arrière-plan superposé vraiment facilement.</li>
<li><a href="https://developer.mozilla.org/fr/docs/Web/CSS/:modal">La pseudo-classe <code>:modal</code></a> s’applique lorsque <code>&lt;dialog&gt;</code> est ouvert avec la méthode <code>showModal()</code>.</li>
<li>Si votre boîte de dialogue contient un formulaire, utiliser l’attribut <code>method=&quot;dialog&quot;</code> sur le formulaire permet à votre bouton de soumission de fermer la boîte de dialogue en transmettant les données.</li>
</ul>
<p>L’élément <code>&lt;dialog&gt;</code> seul n’est pas (encore) suffisamment cohérent entre les différents navigateurs et technologies d’assistance, <a href="https://www.scottohara.me/blog/2019/03/05/open-dialog.html">comme Scott O&rsquo;Hara (de nouveau) l’a remarqué</a>, mais vous avez saisi le principe : qu’en serait-il si on l’enrichissait en appliquant le motif de conception ARIA <i>dialog</i>, et en s’appuyant sur le comportement natif pour économiser quelques lignes de JavaScript ?</p>
<p>C’est plus ou moins <a href="https://web.dev/building-a-dialog-component/">ce qu’Adam Argyle a exploré avec son composant <i>dialog</i> sur web.dev</a> avec quelques astuces sympathiques à apprendre — gardez cependant à l’esprit que <a href="https://twitter.com/aardrian/status/1586792250113232896">les contenus sur web.dev ne sont pas testés avec des technologies d’assistance ni contre les WCAG</a>.</p>
<p><a href="https://css-tricks.com/dialog-components-roll-your-own/">Construire un composant <i>dialog</i> n’est vraiment pas évident</a>, et <a href="https://www.smashingmagazine.com/2021/07/accessible-dialog-from-scratch/">Kitty Giraudel a détaillé ce dont vous avez besoin pour faire un bon composant <i>dialog</i></a>. Depuis la rédaction de ces articles, le support de <code>&lt;dialog&gt;</code> s’est considérablement amélioré et <a href="https://wpt.fyi/interop-2022">fait même partie  d’Interop 2022</a>, donc attendez-vous à ce que le support s’améliore encore en ces derniers jours de 2022.</p>
<p>C’est probablement l’exemple le moins évident, puisqu’en parlant d’amélioration progressive l’élément <code>&lt;dialog&gt;</code> pourrait être un mauvais choix : il ne peut tout bonnement pas fonctionner sans JavaScript. Mais si votre JavaScript est en panne pour une raison inopinée, vos écouteurs d’événement pourraient toujours fonctionner.</p>
<h2>Conclusion</h2>
<p>HTML est incroyable. Ça n’est pas suffisant pour proposer un expérience accessible à tous les utilisateurs, comme <a href="https://daverupert.com/2020/02/html-the-inaccessible-parts/">Dave Rupert l’a mis en exergue il y a deux dans <cite lang="en">HTML: the inaccessible parts</cite></a> — bien que certains de ces exemples ne sont plus d’actualité, corrigés dans les navigateurs ou technologies d’assistance.</p>
<p>Mais ne pas être parfait est probablement toujours mieux qu’être neutre, n’est-ce pas ?</p>
<p>Je crois que c’est le genre de choses qu’HTML permet : <code>&lt;details&gt;</code> et <code>&lt;summary&gt;</code> finiront par être implémentés et restitués de façon cohérente aux technologies d’assistance, rendant les enrichissements avec ARIA caduques. Le travail de Scott, du test très avancé aux articles de blogs et à l’ouverture de tickets de bug, est la voie à suivre. Les implémentations complètes dans les bibliothèques comme <a href="https://a11y-dialog.netlify.app/">a11y-dialog de Kitty Giraudel</a> permettent de gagner en maturité et de clarifier les attentes pour ces composants. Et avec l’augmentation des usages, les navigateurs et technologies d’assistance vont certainement reconsidérer leurs priorisations, dans des opérations comme Interop ou <a href="https://aria-at.w3.org/">ARIA-AT</a>.</p>
<p>Alors utilisons, testons, et aidons les navigateurs et technologies d’assistance à supporter ces nouveaux éléments HTML !</p>
